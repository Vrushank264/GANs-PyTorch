import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.utils as vutils
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as anim
import random
from utils import get_data
from dcgan import weights_gen,Generator,Discriminator

LR_GEN = 0.0002
LR_DISC = 0.00005
Z_DIM = 100
NUM_EPOCHS = 10
PATH = 'E:/Computer Vision/DCGAN/models'

seed = 211
random.seed(seed)
torch.manual_seed(seed)

device = torch.device('cuda')
print(device, 'will be used.')
loader = get_data()

#Plotting Training Images
sample_batch = next(iter(loader))
plt.figure(figsize=(16,16))
plt.axis('off')
plt.title('Training Images')
plt.imshow(np.transpose(vutils.make_grid(
    sample_batch[0].to(device)[:64],padding=2, normalize=True
    ).cpu(),(1,2,0)))
plt.show()

#Generator
netG = Generator(Z_DIM, 64).to(device)
netG.apply(weights_gen)

#Discriminator
netD = Discriminator(64).to(device)

criterion = nn.BCELoss()
fixed_noise = torch.randn(64, Z_DIM, 1, 1, device=device)

optG = optim.Adam(netG.parameters(),lr = LR_GEN, betas=(0.5,0.999))
optD = optim.Adam(netD.parameters(),lr = LR_DISC, betas = (0.5,0.999))

real_label = 1
fake_label = 0

img_list = []
G_losses = []
D_losses = []

iters = 0

print('Starting Training Loop...')

for epoch in range(1, NUM_EPOCHS + 1):
    print('epoch: ',epoch)
    for i,data in enumerate(loader):
        
        #Generate Noise and give it as an input to the Generator
        
        noise = torch.randn(64, Z_DIM, 1, 1, device = device)
        fake_data = netG(noise)
        
        #---------------------------------
        # Discriminator(netD) Training
        #----------------------------------
        real_data = data[0].to(device)
        netD.zero_grad()
        output = netD(real_data).reshape(-1)
        lossD_real = criterion(output,torch.ones_like(output))
        lossD_real.backward()
        D_x = output.mean().item()
        
        output1 = netD(fake_data.detach()).reshape(-1)
        lossD_fake = criterion(output1,torch.zeros_like(output1))
        lossD_fake.backward()
        D_G_z1 = output1.mean().item()
        lossD = lossD_real + lossD_fake
        optD.step()
        
        #----------------------------------
        #   Generator(netG) Training 
        #----------------------------------
        netG.zero_grad()
        output2 = netD(fake_data).reshape(-1)
        lossG = criterion(output2,torch.ones_like(output2))
        lossG.backward()
        D_G_z2 = output2.mean().item()
        optG.step()
        
        #Printing Losses
        num_e = 10
        if i%50 == 0:
            print('[%d/%d][%d/%d]\tLoss_D: %.4f\tLoss_G: %.4f\tD(x): %.4f\tD(G(z)): %.4f / %.4f'
                  % (epoch, num_e , i, len(loader),
                     lossD.item(), lossG.item(), D_x, D_G_z1, D_G_z2))
        G_losses.append(lossG.item())
        D_losses.append(lossD.item())
        
        
        #Getting images to generate GIF
        if(iters % 100 == 0 or epoch == 0 or epoch == 10):
            
            with torch.no_grad():
                fake_data = netG(fixed_noise).detach().cpu()
            img_list.append(vutils.make_grid(fake_data,padding=2,normalize = True))
        
        iters += 1
    
    #Plotting Images generated by the Generator along with the losses
    
    if (epoch % 2 == 0):
       print('Plotting the image and loss...')
       fig = plt.figure(figsize=(8,8))
       plt.axis('off')
       plt.imshow(np.transpose(img_list[-1] ,(1,2,0)))
       fname = f'E:/Computer Vision/Data/newer_img{epoch+1}.png'
       plt.savefig(fname)
       plt.show()
       
       plt.figure(figsize = (10,5))
       plt.title('Generator and Discriminator loss')
       plt.plot(G_losses,label = 'G')
       plt.plot(D_losses,label = 'D')
       plt.xlabel('Iterations')
       plt.ylabel('Loss')
       plt.legend()
       plt.show()
           
       print('Saving models...')
       torch.save(netG.state_dict(), open(PATH + f'generator_at_epoch{epoch}.pth' , 'wb'))
       torch.save(netD.state_dict(), open(PATH + f'discriminator_at_epoch{epoch}.pth' , 'wb'))

#GIF generation
fig = plt.figure(figsize=(8,8))
plt.axis('off')
ims = [[plt.imshow(np.transpose(i,(1,2,0)),animated = True)] for i in img_list]
animation = anim.ArtistAnimation(fig,ims,interval = 100,repeat_delay = 100, blit = True)
plt.show()
animation.save('Clothes1.gif',dpi = 80, writer='imagekclick')
